# Readme.md

# Решение первого задания Яндекс ШРИ 2021

## Запуск проекта

Для запуска проекта необходимо сначала установить зависимости:

```bash
npm install
```

Далее запуск выполняется командой:

```bash
npm start
```

Для сборки проекта нужно вызвать команду:

```bash
npm run build
```

## Особенности реализации

- Слайд vote

    В спецификации к макету было указано, что отступы могут тянутся. Я до конца не понял имелась в виду ли адаптивность или интерактивность. Если на данном слайде попробовать пролистнуть за экран, то отступы между картами растянутся или сожмутся - в зависимости от направления.

    Также была реализована небольшая интерактивность в плане выбора карт - нажимая на определённую карту, она подсвечивается как выбранная, а у других выбранных карт данное состояние пропадает.

- Слайд chart

    На данном слайде тоже реализованы интерактивные тянущиеся отступы - в вертикальной ориентации можно увидеть информацию по предыдущим спринтам, если потянуть вправо саму статистику; в горизонтальной ориентации тоже можно увидеть дополнительную информацию, если тянуть к середине слайда

- Слайд diagram

    Здесь у меня возникли проблемы с реализацией самой статистики. Я пробовал её реализовывать с помощью SVG (стилизовал границу круга), но столкнулся с проблемой при переносе градиентов - цвета не совпадали, сама SVG была с неровными краями, а тени вылезали за элемент. Далее я пробовал реализовывать через canvas с помощью chart.js библиотеки. Опять меня остановили градиенты, ну и ещё js при тестировании не выполнялся и диаграмма не отрисовывалась. Наконец, я попробовал реализовать на CSS - я создавал кольца с нужным градиентом и обрезал их на определённый градус с помощью свойства clip-path. Однако, в данном решении я всё равно не смог сделать необходимое скругление (кроме как с помощью тени для заданных значений диаграммы, что было необходимо для прохождения автотестов). В данный момент в репозитории итоговый вариант.

    Коммиты, где можно посмотреть прошлые версии:
    * [Версия с canvas (chart.js)](https://github.com/DaniilGorokhov/Yndx-Shri-Stories-1/commit/b87569580a635bbc464effefb7ce36570f2c0009)
    * [Версия с SVG stroke](https://github.com/DaniilGorokhov/Yndx-Shri-Stories-1/tree/c5550746bff44bffb0b9c2f2927787e2eaafb708). Пометка: при открытии localhost:8080?slide=9 будет открыт слайд без градиентов, а чтобы открыть слайд с градиентами нужно добавить параметр other_solving [localhost:8080?slide=9&other_solving](http://localhost:8080?slide=9&other_solving)

- Слайд activity

    Для построения самой тепловой карты в результате использовались картинки (одна картинка для каждого элемента), из-за чего есть проблемы при загрузке страницы. Данное решение было принято, так как у других решений были проблемы с отображением (возможно чего-то не нашёл):

    1. Составление фигуры из 3 плоских.

        Сначала поясню зачем я составляю фигуру. Элемент тепловой карты представляет собой 6-угольник и 3 (может быть 2) прямоугольника для наложения градиентов и теней:

        ![Картинка для пояснения](https://i8.wampi.ru/2021/03/05/DLY_POYSNENIY.png)

        Поэтому можно сначала нужно составить 6-угольник.

        Его можно составить разными способами, например из прямоугольника - посередине и двух треугольников - сверху и снизу или из двух прямоугольников, повёрнутых на 45 градусов и прямоугольника посередине (пример - [https://codepen.io/OneLeques/pen/QWGrNrv](https://codepen.io/OneLeques/pen/QWGrNrv)).

        Данный способ не подошёл, так как компоненты накладываются друг на друга.

    2. 3d трансформации.

        Здесь я столкнулся с проблемой накладывания градиента. Так как фигура составная градиент, либо можно наложить на каждый компонент, либо с помощью fixed зафиксировать положение градиента. Оба вариант не приводят нас к желаемому результату, пример - [https://codepen.io/OneLeques/pen/rNWvJMG](https://codepen.io/OneLeques/pen/rNWvJMG)

    3. Также, я рассматривал вариант с использованием clip-path, но внешний вид отличался от вида на макете довольно существенно, из-за того, что градиент накладывался не на полученную вырезанную фигуру, а на изначальную.

## Использованные технологии

1. Сборка - webpack

    Я выбрал именно webpack для сборки приложения, так как webpack имеет большую популярность, от чего зависит поддержка различных плагинов и лоадеров, а также их дальнейшее развитие.

2. Шаблонизатор - EJS

    В связи с тем, что приложение должно в зависимости от данных генерировать HTML-разметку и выполнять данную операцию на стороне клиента, нужно было выбрать шаблонизатор, который весил бы немного и предоставлял хороший функционал.

    При выборе шаблонизатора я опирался на две характеристики: популярность шаблонизатора и его вес.

    Самыми популярными (согласно количеству звёзд на github и установок npm пакета) являются следующие шаблонизаторы:

    - Pug
    - Handlebars
    - EJS
    - Mustache.js

    Pug и Handlebars являются достаточно тяжёлыми пакетами (опирался на результаты проверки веса с помощью howfat npm cli).

    Среди оставшихся двух выбран был EJS, так как он имеет бОльшую популярность и при использовании ejs-compiled-webpack (шаблоны компилируются во время сборки, за счёт чего, на стороне клиента только рендеринг) имеет меньший вес.

3. Работа с CSS - SASS, PostCSS

    Для упрощения процесса разработки и расширения возможностей был использован SASS (синтаксис - SCSS). Использовались его возможности создания нескольких классов с помощью цикла, вложенное объявление, функции для работы с цветами и так далее.

    PostCSS нужен был для применения autoprefixer (чтобы не думать о префиксах) и cssnano (чтобы очистить и оптимизировать CSS).

    Во время разработки использовалась методология БЭМ для переиспользования компонентов → директория blocks - все блоки, использованные в проекте.

4. Линтинг

    Для поддержания единого стиля кода были использованы ESLint и stylelint, а во избежание попадания 'грязного' кода в репозиторий использовался пакет husky для работы с git хуками.

5. Express

    Express использован в качестве веб-сервера, так как он очень прост в использовании и популярен.

6. Uglify.js

    Uglify.js использовался для оптимизации размера скрипта. Аналогов, которые были бы чем-то лучше или популярнее, чем Uglify.js я не нашёл.

7. Backstop.js

    Данный пакет был использован для тестирования вёрстки. После первой отправки своего решения на автоматическое тестирование, я столкнулся с большим количеством мелких сдвигов контента, а иногда просто с несоответствием размеров. После этого я подумал о том, что было бы неплохо проверять свою вёрстку локально на основе предоставленных скриншотов. Backstop оказался интересным решением, которое предоставляло все необходимые мне возможности.
