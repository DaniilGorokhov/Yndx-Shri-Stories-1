# Readme.md

# Решение первого задания Яндекс ШРИ 2021

## Запуск проекта

Для запуска проекта необходимо сначала установить зависимости:

```bash
npm install
```

Далее запуск выполняется командой:

```bash
npm start
```

Для сборки проекта нужно вызвать команду:

```bash
npm run build
```

## Особенности реализации

- Слайд vote

    В спецификации к макету было указано, что отступы могут тянутся. Я до конца не понял имелось в виду ли адаптивность или интерактивность. Если на данном слайде попробовать пролистнуть за экран, то отступы между картами растянутся.

    Также была реализована небольшая интерактивность в плане выбора карт - нажимая на определённую карту, она подсвечивается как выбранная, а у других выбранных карт данное состояние пропадает.

- Слайд chart

    На данном слайде тоже реализованы интерактивные тянущиеся отступы - в вертикальной ориентации можно увидеть информацию по предыдущим спринтам, если потянуть вправо саму статистику; в горизонтальной ориентации они просто тянутся

- Слайд diagram

    Здесь у меня возникли проблемы с реализацией самой статистики. Я не нашёл решения для создания данного блока статистики через чистый CSS (основная проблема - это скругления и градиент), поэтому попробовал реализовать с помощью SVG, но здесь не получалось наложить необходимые тени на градиент (они вылезали за края определённой области, а края градиентов были неровные).

    У данного слайда по итоге есть две реализации: 

    1. Без градиентов, при переходе на слайд по адресу [localhost:8080?slide=9](http://localhost:8080?slide=9). 
    2. С градиентами, при переходе на слайд с дополнительным параметром - other_solving → адрес - [localhost:8080?slide=9&other_solving](http://localhost:8080?slide=9&other_solving) (светлая тема работает также)
- Слайд activity

    Для построения самой тепловой карты в результате использовались картинки (одна картинка для каждого элемента), из-за чего есть проблемы при загрузке страницы. Данное решение было принято, так как у других решений были проблемы с отображением (возможно чего-то не нашёл):

    1. Составление фигуры из 3 плоских.

        Сначала поясню зачем я составляю фигуру. Элемент тепловой карты представляет собой 6-угольник и 3 (может быть 2) прямоугольника для наложения градиентов и теней:

        ![Картинка для пояснения](https://i8.wampi.ru/2021/03/05/DLY_POYSNENIY.png)

        Поэтому можно сначала нужно составить 6-угольник.

        Его можно составить разными способами, например из прямоугольника - посередине и двух треугольников - сверху и снизу или из двух прямоугольников, повёрнутых на 45 градусов и прямоугольника посередине (пример - [https://codepen.io/OneLeques/pen/QWGrNrv](https://codepen.io/OneLeques/pen/QWGrNrv)).

        Данный способ не подошёл, так как компоненты накладываются друг на друга.

    2. 3d трансформации.

        Здесь я столкнулся с проблемой накладывания градиента. Так как фигура составная градиент, либо можно наложить на каждый компонент, либо с помощью fixed зафиксировать положение градиента. Оба вариант не приводят нас к желаемому результату, пример - [https://codepen.io/OneLeques/pen/rNWvJMG](https://codepen.io/OneLeques/pen/rNWvJMG)

    3. Также, я рассматривал вариант с использованием clip-path, но внешний вид отличался от вида на макете довольно существенно.

### Примечание по структуре приложения

При разработке первых 4 слайдов, из-за неопытности я обрабатывал все данные, непосредственно, в шаблоне, что оказалось крайне неудобным (даже линтер не подключить нормально) и без возможности переиспользовать какой-либо код. Для 5 слайда вся логика обработки данных была вынесена в отдельный файл. При дальнейшем развитие приложения мне бы хотелось вынести логику остальных слайдов так же в отдельные файлы.

## Использованные технологии

1. Сборка - webpack

    Я выбрал именно webpack для сборки приложения, так как webpack имеет большую популярность, от чего зависит поддержка различных плагинов и лоадеров, а также их дальнейшее развитие.

2. Шаблонизатор - EJS

    В связи с тем, что приложение должно в зависимости от данных генерировать HTML-разметку и выполнять данную операцию на стороне клиента, нужно было выбрать шаблонизатор, который весил бы немного и предоставлял хороший функционал.

    При выборе шаблонизатора я опирался на две характеристики: популярность шаблонизатора и его вес.

    Самыми популярными (согласно количеству звёзд на github и установок npm пакета) являются следующие шаблонизаторы:

    - Pug
    - Handlebars
    - EJS
    - Mustache.js

    Pug и Handlebars являются достаточно тяжёлыми пакетами (опирался на результаты проверки веса с помощью howfat npm cli).

    Среди оставшихся двух выбран был EJS, так как он имеет бОльшую популярность и при использовании ejs-compiled-webpack (шаблоны компилируются во время сборки, за счёт чего, на стороне клиента только рендеринг) имеет меньший вес.

3. Работа с CSS - SASS, PostCSS

    Для упрощения процесса разработки и расширения возможностей был использован SASS (синтаксис - SCSS). Использовались его возможности создания нескольких классов с помощью цикла, вложенное объявление, функции для работы с цветами и так далее.

    PostCSS нужен был для применения autoprefixer (чтобы не думать о префиксах) и cssnano (чтобы очистить и оптимизировать CSS).

    Во время разработки использовалась методология БЭМ для переиспользования компонентов → директория blocks - все блоки, использованные в проекте.

4. Линтинг

    Для поддержания единого стиля кода были использованы ESLint и stylelint, а во избежание попадания 'грязного' кода в репозиторий использовался пакет husky для работы с git хуками.

5. Express

    Express использован в качестве веб-сервера, так как он очень прост в использовании и популярен.
