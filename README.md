# Readme.md

# Решение первого задания Яндекс ШРИ 2021

## Запуск проекта

Для запуска проекта необходимо сначала установить зависимости:

```bash
npm install
```

Далее запуск выполняется командой:

```bash
npm start
```

Для сборки проекта нужно вызвать команду:

```bash
npm run build
```

## Особенности реализации

- Слайд vote

    В спецификации к макету было указано, что отступы могут тянутся. Я до конца не понял имелась в виду ли адаптивность или интерактивность. Если на данном слайде попробовать пролистнуть за экран, то отступы между картами растянутся или сожмутся - в зависимости от направления.

    Также была реализована небольшая интерактивность в плане выбора карт - нажимая на определённую карту, она подсвечивается как выбранная, а у других выбранных карт данное состояние пропадает.

- Слайд chart

    На данном слайде тоже реализованы интерактивные тянущиеся отступы - в вертикальной ориентации можно увидеть информацию по предыдущим спринтам, если потянуть вправо саму статистику; в горизонтальной ориентации тоже можно увидеть дополнительную информацию, если тянуть к середине слайда

- Слайд diagram

    Здесь у меня возникли проблемы с реализацией самой статистики. Я не нашёл решения для создания данного блока статистики через чистый CSS (основная проблема – это скругления и градиент), поэтому попробовал реализовать с помощью SVG, но здесь не получалось наложить необходимые тени на градиент (они вылезали за края определённой области, а края градиентов были неровные). Далее я попробовал реализовать данный слайд с помощью [chart.js](https://www.chartjs.org/) библиотеки и, соответственно, canvas. Однако и здесь были ощутимые проблемы с градиентами, плюс библиотека весит достаточно много и подключить её удалось только с использованием Uglify.js (вес сборки без минификации был больше 1 МБ).
- Слайд activity

    Для построения самой тепловой карты в результате использовались картинки (одна картинка для каждого элемента), из-за чего есть проблемы при загрузке страницы. Данное решение было принято, так как у других решений были проблемы с отображением (возможно чего-то не нашёл):

    1. Составление фигуры из 3 плоских.

        Сначала поясню зачем я составляю фигуру. Элемент тепловой карты представляет собой 6-угольник и 3 (может быть 2) прямоугольника для наложения градиентов и теней:

        ![Картинка для пояснения](https://i8.wampi.ru/2021/03/05/DLY_POYSNENIY.png)

        Поэтому можно сначала нужно составить 6-угольник.

        Его можно составить разными способами, например из прямоугольника - посередине и двух треугольников - сверху и снизу или из двух прямоугольников, повёрнутых на 45 градусов и прямоугольника посередине (пример - [https://codepen.io/OneLeques/pen/QWGrNrv](https://codepen.io/OneLeques/pen/QWGrNrv)).

        Данный способ не подошёл, так как компоненты накладываются друг на друга.

    2. 3d трансформации.

        Здесь я столкнулся с проблемой накладывания градиента. Так как фигура составная градиент, либо можно наложить на каждый компонент, либо с помощью fixed зафиксировать положение градиента. Оба вариант не приводят нас к желаемому результату, пример - [https://codepen.io/OneLeques/pen/rNWvJMG](https://codepen.io/OneLeques/pen/rNWvJMG)

    3. Также, я рассматривал вариант с использованием clip-path, но внешний вид отличался от вида на макете довольно существенно.

### Примечание по структуре приложения

Изначально при разработке шаблонов, вся их логика работы с данными проводилась внутри, то есть код для обработки данных не валидировался линтером, его никак нельзя было переиспользовать и так далее. В какой-то момент я начал переписывать всю логику для выноса в отдельные модули, однако это занимало достаточно много времени, поэтому для двух слайдов - leaders и chart - переписи логики не было, но я понимаю, что это ошибка, и её нужно учесть при разработке последующих проектов.

## Использованные технологии

1. Сборка - webpack

    Я выбрал именно webpack для сборки приложения, так как webpack имеет большую популярность, от чего зависит поддержка различных плагинов и лоадеров, а также их дальнейшее развитие.

2. Шаблонизатор - EJS

    В связи с тем, что приложение должно в зависимости от данных генерировать HTML-разметку и выполнять данную операцию на стороне клиента, нужно было выбрать шаблонизатор, который весил бы немного и предоставлял хороший функционал.

    При выборе шаблонизатора я опирался на две характеристики: популярность шаблонизатора и его вес.

    Самыми популярными (согласно количеству звёзд на github и установок npm пакета) являются следующие шаблонизаторы:

    - Pug
    - Handlebars
    - EJS
    - Mustache.js

    Pug и Handlebars являются достаточно тяжёлыми пакетами (опирался на результаты проверки веса с помощью howfat npm cli).

    Среди оставшихся двух выбран был EJS, так как он имеет бОльшую популярность и при использовании ejs-compiled-webpack (шаблоны компилируются во время сборки, за счёт чего, на стороне клиента только рендеринг) имеет меньший вес.

3. Работа с CSS - SASS, PostCSS

    Для упрощения процесса разработки и расширения возможностей был использован SASS (синтаксис - SCSS). Использовались его возможности создания нескольких классов с помощью цикла, вложенное объявление, функции для работы с цветами и так далее.

    PostCSS нужен был для применения autoprefixer (чтобы не думать о префиксах) и cssnano (чтобы очистить и оптимизировать CSS).

    Во время разработки использовалась методология БЭМ для переиспользования компонентов → директория blocks - все блоки, использованные в проекте.

4. Линтинг

    Для поддержания единого стиля кода были использованы ESLint и stylelint, а во избежание попадания 'грязного' кода в репозиторий использовался пакет husky для работы с git хуками.

5. Express

    Express использован в качестве веб-сервера, так как он очень прост в использовании и популярен.

6. Uglify.js

    Uglify.js использовался для оптимизации размера скрипта. Аналогов, которые были бы чем-то лучше или популярнее, чем Uglify.js я не нашёл.

7. Backstop.js

    Данный пакет был использован для тестирования вёрстки. После первой отправки своего решения на автоматическое тестирование, я столкнулся с большим количеством мелких сдвигов контента, а иногда просто с несоответствием размеров. После этого я подумал о том, что было бы неплохо проверять свою вёрстку локально на основе предоставленных скриншотов. Backstop оказался интересным решением, которое предоставляло все необходимые мне возможности.